```bash

# Independently and randomly sample J spatial masks from Bernoulli(1 - prob_s), prob_s is the probability for spatial context masking of skeletal structural locations
def PSCM(prob_s):
     s_mask = np.zeros([J, ])
     # number of zero masks is from 0 to J-1
     while np.mean(s_mask) == 0:
          prob = np.random.uniform(0, 1, [J, ])
          s_mask = prob >= prob_s
     return s_mask

# Independently and randomly sample f temporal masks from Bernoulli(1 - prob_t), prob_t is the probability for temporal context masking of skeletal motion trajectories 
def PTCM(prob_t):
     t_mask = np.zeros([f, ])
     # number of zero masks is from 0 to f-1
     while np.mean(t_mask) == 0:
          prob = np.random.uniform(0, 1, [f, ])
          t_mask = prob >= prob_t
     return t_mask

# Spatial skeleton sequence reconstruction and inference based on PSCM
# h with shape [batch_size, f, J, H]
# spatial_mask with shape [batch_size, J], generated by PSCM(prob_s)
# gt_pos with shape [batch_size, f, J, 3]
def skeleton_recon_loss(h, spatial_mask, gt_pos):
     # Apply masks to structural locations of joints in the skeleton and average unmasked representations
     mask_h = apply_mask_and_ave(h, spatial_mask)
     # Use MLP to predict ground-truth structural locations of joints [batch_size, f, J, 3]
     pred_pos = MLP(mask_h)
     # Compute MSE loss between predicted structural locations and ground-truth structural locations of skeleton sequences
     s_recon_loss = MSE_loss(pred_pos, gt_pos) / batch_size
     return s_recon_loss

# Temporal skeleton sequence reconstruction and inference based on PTCM
# traj_h with shape [batch_size, J, f, H]
# temporal_mask with shape [batch_size, f], generated by PTCM(prob_t)
# gt_pos with shape [batch_size, f, J, 3]
def trajectory_recon_loss(traj_h, temporal_mask, gt_pos):
     # Apply masks to motion trajectories of joints and average unmasked representations
     mask_traj_h = apply_mask_and_ave(traj_h, temporal_mask)
     # Use MLP to predict ground-truth motion trajectories of joints [batch_size, J, f, 3]
     pred_pos = MLP(mask_traj_h)
     # Transpose shape [batch_size, J, f, 3] to shape [batch_size, f, J, 3] to match the original skeleton sequence shape
     pred_pos = transpose(pred_pos, [0, 2, 1, 3])
     # Compute MSE loss between predicted motion trajectories and ground-truth motion trajectories of skeleton sequences
     t_recon_loss = MSE_loss(pred_pos, gt_pos) / batch_size
     return t_recon_loss

# Spatial-temporal Skeleton Context Reconstruction (SSCR) loss for Prompter learning
def Prompt_loss():
     return alpha * skeleton_recon_loss(h, spatial_mask, gt_pos) + (1 - alpha) * trajectory_recon_loss(traj_h, temporal_mask, gt_pos)

```
